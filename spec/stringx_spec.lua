local sx = require('stringx')

describe("String extension library", function()
    describe('escape_pattern', function()
        it('should properly escape strings', function()
            assert.are.equal(sx.escape_pattern('%asdf'), '%%asdf')
        end)
    end)

    describe('isalpha', function()
        it('should detect alphabetic strings', function()
            assert.is_true(sx.isalpha('asdfASDF'))
        end)

        it('should return false for others', function()
            assert.is_false(sx.isalpha('asdf1'))
        end)
    end)

    describe('isdigit', function()
        it('should detect numeric strings', function()
            assert.is_true(sx.isdigit('1234'))
        end)

        it('should return false for others', function()
            assert.is_false(sx.isdigit('1234a'))
        end)
    end)

    describe('isalnum', function()
        it('should detect alphanumeric strings', function()
            assert.is_true(sx.isalnum('asdf123'))
        end)

        it('should return false for others', function()
            assert.is_false(sx.isalnum('asdf!123'))
        end)
    end)

    describe('isspace', function()
        it('should detect strings that are whitespace', function()
            assert.is_true(sx.isspace('  \r\n\t'))
        end)

        it('should return false for others', function()
            assert.is_false(sx.isspace('  asd  '))
        end)
    end)

    describe('islower', function()
        it('should detect strings that are lowercase', function()
            assert.is_true(sx.islower('lowercase'))
        end)

        it('should return false for others', function()
            assert.is_false(sx.islower('not LOWERcase'))
        end)
    end)

    describe('isupper', function()
        it('should detect strings that are lowercase', function()
            assert.is_true(sx.isupper('UPPERCASE'))
        end)

        it('should return false for others', function()
            assert.is_false(sx.isupper('NOT upperCASE'))
        end)
    end)

    describe('at', function()
        it('will return the character at the given index', function()
            assert.are.equal(sx.at('foobar', 4), 'b')
        end)
    end)

    describe('shorten', function()
        it('should not change short strings', function()
            assert.are.equal(sx.shorten('foo', 10), 'foo')
        end)

        it('should shorten to just dots', function()
            assert.are.equal(sx.shorten('bar', 0), '')
            assert.are.equal(sx.shorten('bar', 1), '.')
            assert.are.equal(sx.shorten('bar', 2), '..')
        end)

        it('should shorten long strings', function()
            assert.are.equal(sx.shorten('foobar123', 6), 'foo...')
        end)

        it('should shorten in reverse properly', function()
            assert.are.equal(sx.shorten('foobar123', 6, true), '...123')
        end)

        it('properly handles exact-sized strings', function()
            assert.are.equal(sx.shorten('foobar', 6), 'foobar')
            assert.are.equal(sx.shorten('foobar', 6, true), 'foobar')
        end)
    end)

    describe('capitalize', function()
        it('will capitalize a string', function()
            assert.are.equal(sx.capitalize('foobar'), 'Foobar')
        end)

        it('will handle short strings', function()
            assert.are.equal(sx.capitalize('f'), 'F')
            assert.are.equal(sx.capitalize(''), '')
        end)
    end)

    describe('chomp', function()
        it('will trim all types of newlines', function()
            assert.are.equal(sx.chomp('foobar\r'), 'foobar')
            assert.are.equal(sx.chomp('foobar\n'), 'foobar')
            assert.are.equal(sx.chomp('foobar\r\n'), 'foobar')
            assert.are.equal(sx.chomp('foobar\n\r'), 'foobar\n')
        end)

        it('will trim user-defined separators', function()
            assert.are.equal(sx.chomp('foobar', 'r'), 'fooba')
            assert.are.equal(sx.chomp('foobaq', 'r'), 'foobaq')
        end)
    end)

    describe('chop', function()
        it('will remove the last character', function()
            assert.are.equal(sx.chop('foobar'), 'fooba')
        end)

        it('will remove a trailing newline pair', function()
            assert.are.equal(sx.chop('foobar\r\n'), 'foobar')
        end)
    end)

    describe('delete', function()
        it('will remove a single character from the string', function()
            assert.are.equal(sx.delete('foobar', 'o'), 'fbar')
        end)

        it('will remove multiple characters from the string', function()
            assert.are.equal(sx.delete('foobar', {'o', 'a'}), 'fbr')
        end)
    end)

    describe('lstrip', function()
        it('will strip whitespace by default', function()
            assert.are.equal(sx.lstrip('   asdf'), 'asdf')
        end)

        it('will strip user-given patterns', function()
            assert.are.equal(sx.lstrip('aaaaaafoobar', 'a+'), 'foobar')
        end)
    end)

    describe('rstrip', function()
        it('will strip whitespace by default', function()
            assert.are.equal(sx.rstrip('asdf     '), 'asdf')
        end)

        it('will strip user-given patterns', function()
            assert.are.equal(sx.rstrip('foobaraaaaaaaa', 'a+'), 'foobar')
        end)
    end)

    describe('strip', function()
        it('will strip whitespace by default', function()
            assert.are.equal(sx.strip('  asdf  '), 'asdf')
        end)

        it('will strip user-given patterns', function()
            assert.are.equal(sx.strip('aaaafoobaraaaa', 'a+'), 'foobar')
        end)
    end)

    describe('lfind', function()
        it('will find a given pattern', function()
            assert.are.equal(sx.lfind('foobar', 'o'), 2)
        end)

        it('will respect the "first" parameter', function()
            assert.are.equal(sx.lfind('foobar', 'o', 3), 3)
        end)

        it('will respect the "last" parameter', function()
            assert.are.equal(sx.lfind('ababab', 'ab', 2, 5), 3)
            assert.are.equal(sx.lfind('ababab', 'ab', 2, 3), nil)
        end)

        it('will find multi-character strings', function()
            assert.are.equal(sx.lfind('foobar', 'bar'), 4)
        end)

        it('will return nil on failure', function()
            assert.are.equal(sx.lfind('foobar', 'q'), nil)
        end)
    end)

    describe('rfind', function()
        it('will find a given pattern', function()
            assert.are.equal(sx.rfind('foobar', 'o'), 3)
        end)

        it('will respect the "first" parameter', function()
            assert.are.equal(sx.rfind('foobar', 'o', 3), 3)
        end)

        it('will respect the "last" parameter', function()
            assert.are.equal(sx.rfind('ababab', 'ab', 2, 5), 3)
        end)

        it('will find multi-character strings', function()
            assert.are.equal(sx.rfind('foobar', 'bar'), 4)
        end)

        it('will return nil on failure', function()
            assert.are.equal(sx.rfind('foobar', 'q'), nil)
        end)
    end)

    describe('replace', function()
        it('will replace strings', function()
            assert.are.equal(sx.replace('foobar', 'foo', 'bar'), 'barbar')
        end)

        it('respects the "count" parameter', function()
            assert.are.equal(sx.replace('11223344', '1', '7', 1), '71223344')
        end)

        it('will replace pattern characters', function()
            assert.are.equal(sx.replace('foo%abar', '%a', 'qq'), 'fooqqbar')
            assert.are.equal(sx.replace('foo[a-z].?bar', '[a-z].?', 'qq'), 'fooqqbar')
        end)
    end)

    describe('endswith', function()
        it('will check simple strings', function()
            assert.is_true(sx.endswith('foobar', 'bar'))
            assert.is_false(sx.endswith('foobar', 'qar'))
        end)

        it('will check multiple suffixes', function()
            assert.is_false(sx.endswith('foobar', {'aa', 'bb'}))
            assert.is_true(sx.endswith('foobar', {'aa', 'bb', 'bar'}))
        end)
    end)

    describe('startswith', function()
        it('will check simple strings', function()
            assert.is_true(sx.startswith('foobar', 'foo'))
            assert.is_false(sx.startswith('foobar', 'qoo'))
        end)

        it('will check multiple suffixes', function()
            assert.is_false(sx.startswith('foobar', {'aa', 'bb'}))
            assert.is_true(sx.startswith('foobar', {'aa', 'bb', 'foo'}))
        end)
    end)

    describe('count', function()
        it('will count the number of characters in a string', function()
            assert.are.equal(sx.count('1223334444', '1'), 1)
            assert.are.equal(sx.count('1223334444', '0'), 0)
        end)

        it('respects the "start" parameter', function()
            assert.are.equal(sx.count('1223334444', '2', 3), 1)
        end)

        it('respects the "fin" parameter', function()
            assert.are.equal(sx.count('4444', '4', 2, 3), 2)
        end)
    end)

    describe('partition', function()
        it('will split the string', function()
            local before, match, after = sx.partition('asdf', 's')
            assert.are.equal(before, 'a')
            assert.are.equal(match, 's')
            assert.are.equal(after, 'df')
        end)

        it('will return blanks if no match', function()
            local before, match, after = sx.partition('asdf', 'q')
            assert.are.equal(before, 'asdf')
            assert.are.equal(match, '')
            assert.are.equal(after, '')
        end)

        it('handles matches at string ends', function()
            local before, match, after = sx.partition('asdf', 'f')
            assert.are.equal(before, 'asd')
            assert.are.equal(match, 'f')
            assert.are.equal(after, '')

            before, match, after = sx.partition('asdf', 'a')
            assert.are.equal(before, '')
            assert.are.equal(match, 'a')
            assert.are.equal(after, 'sdf')
        end)
    end)

    describe('rpartition', function()
        it('will split the string', function()
            local before, match, after = sx.rpartition('asdfasdf', 'a')
            assert.are.equal(before, 'asdf')
            assert.are.equal(match, 'a')
            assert.are.equal(after, 'sdf')
        end)

        it('will return blanks if no match', function()
            local before, match, after = sx.rpartition('asdf', 'q')
            assert.are.equal(before, 'asdf')
            assert.are.equal(match, '')
            assert.are.equal(after, '')
        end)
    end)

    describe('ljust', function()
        it('will justify to the given length', function()
            assert.are.equal(sx.ljust('foo', 5), 'foo  ')
        end)

        it('will not truncate longer strings', function()
            assert.are.equal(sx.ljust('foobarbaz', 5), 'foobarbaz')
        end)

        it('will pad with the given character', function()
            assert.are.equal(sx.ljust('foo', 5, 'a'), 'fooaa')
        end)
    end)

    describe('rjust', function()
        it('will justify to the given length', function()
            assert.are.equal(sx.rjust('foo', 5), '  foo')
        end)

        it('will not truncate longer strings', function()
            assert.are.equal(sx.rjust('foobarbaz', 5), 'foobarbaz')
        end)

        it('will pad with the given character', function()
            assert.are.equal(sx.rjust('foo', 5, 'a'), 'aafoo')
        end)
    end)

    describe('zfill', function()
        it('will pad to the given length', function()
            assert.are.equal(sx.zfill('123', 5), '00123')
        end)

        it('will not truncate longer strings', function()
            assert.are.equal(sx.zfill('123456', 5), '123456')
        end)
    end)
end)
